"""
FastAPI HTTP server for serving chart images.

This module provides HTTP endpoints for streaming chart images
generated by the household budget analysis tools.
"""

from __future__ import annotations

import logging
from typing import Any

try:
    from fastapi import FastAPI, HTTPException, Query
    from fastapi.middleware.cors import CORSMiddleware
    from fastapi.responses import StreamingResponse

    HAS_FASTAPI = True
except ImportError:
    HAS_FASTAPI = False

from household_mcp.streaming import ImageStreamer
from household_mcp.streaming.global_cache import ensure_global_cache, get_global_cache

logger = logging.getLogger(__name__)


def create_http_app(
    enable_cors: bool = True,
    allowed_origins: list[str] | None = None,
    cache_size: int = 50,
    cache_ttl: int = 3600,
) -> FastAPI:
    """
    Create FastAPI application for chart streaming.

    Args:
        enable_cors: Whether to enable CORS middleware
        allowed_origins: List of allowed origins for CORS.
                        Defaults to ["*"] if None.
        cache_size: Maximum number of cached charts (default: 50)
        cache_ttl: Cache TTL in seconds (default: 3600 = 1 hour)

    Returns:
        Configured FastAPI application

    Raises:
        ImportError: If FastAPI is not installed

    """
    if not HAS_FASTAPI:
        raise ImportError(
            "FastAPI is required for HTTP server. "
            "Install with: pip install household-mcp-server[streaming]"
        )

    app = FastAPI(
        title="Household Budget Chart Server",
        description="HTTP streaming server for household budget charts",
        version="0.1.0",
    )

    # Initialize cache and streamer (use global shared cache when possible)
    chart_cache = get_global_cache() or ensure_global_cache(
        max_size=cache_size, ttl=cache_ttl
    )
    if chart_cache is None:
        # Fallback: raise with clear guidance on missing extras
        raise ImportError(
            "cachetools is required for chart caching. "
            "Install with: pip install household-mcp-server[streaming]"
        )
    image_streamer = ImageStreamer(chunk_size=8192)

    # CORS configuration
    if enable_cors:
        origins = allowed_origins or ["*"]
        app.add_middleware(
            CORSMiddleware,
            allow_origins=origins,
            allow_credentials=True,
            allow_methods=["GET", "POST"],
            allow_headers=["*"],
        )

    # Initialize database manager for duplicate tools
    try:
        import os

        from household_mcp.database.manager import DatabaseManager
        from household_mcp.tools.duplicate_tools import set_database_manager

        data_dir = os.environ.get(
            "DATA_DIR", os.path.join(os.path.dirname(__file__), "../../../data")
        )
        db_path = os.path.join(data_dir, "household.db")
        db_manager = DatabaseManager(db_path=db_path)
        set_database_manager(db_manager)
        logger.info(f"Database manager initialized with db_path: {db_path}")
    except Exception as e:
        logger.warning(f"Could not initialize database manager: {e}")

    @app.get("/api/charts/{chart_id}")
    async def stream_chart(chart_id: str) -> StreamingResponse:  # type: ignore[no-untyped-def]
        """
        Stream a generated chart image.

        Args:
            chart_id: Unique identifier for the chart (cache key)

        Returns:
            StreamingResponse with image data

        Raises:
            HTTPException: If chart not found in cache (404)

        """
        logger.info(f"Request for chart: {chart_id}")

        # Retrieve from cache
        image_data = chart_cache.get(chart_id)
        if image_data is None:
            logger.warning(f"Chart not found: {chart_id}")
            raise HTTPException(status_code=404, detail=f"Chart '{chart_id}' not found")

        # Stream the image
        logger.info(f"Streaming chart: {chart_id} ({len(image_data)} bytes)")
        return image_streamer.create_response(
            image_data,
            media_type="image/png",
            filename=f"chart_{chart_id}.png",
        )

    @app.get("/api/charts/{chart_id}/info")
    async def get_chart_info(chart_id: str) -> dict[str, object]:  # type: ignore[no-untyped-def]
        """
        Get information about a cached chart.

        Args:
            chart_id: Unique identifier for the chart

        Returns:
            Dictionary with chart metadata

        Raises:
            HTTPException: If chart not found in cache (404)

        """
        image_data = chart_cache.get(chart_id)
        if image_data is None:
            raise HTTPException(status_code=404, detail=f"Chart '{chart_id}' not found")

        return {
            "chart_id": chart_id,
            "size_bytes": len(image_data),
            "media_type": "image/png",
        }

    @app.get("/api/cache/stats")
    async def get_cache_stats() -> dict[str, object]:  # type: ignore[no-untyped-def]
        """
        Get cache statistics.

        Returns:
            Dictionary with cache statistics

        """
        return chart_cache.stats()

    @app.delete("/api/cache")
    async def clear_cache() -> dict[str, object]:  # type: ignore[no-untyped-def]
        """
        Clear all cached charts.

        Returns:
            Confirmation message

        """
        chart_cache.clear()
        logger.info("Cache cleared")
        return {"status": "success", "message": "Cache cleared"}

    @app.get("/health")
    async def health_check() -> dict[str, object]:  # type: ignore[no-untyped-def]
        """
        Health check endpoint.

        Returns:
            Health status

        """
        return {"status": "healthy", "cache_size": chart_cache.size()}

    # MCP Tool API endpoints
    @app.get("/api/monthly")
    async def get_monthly_data(  # type: ignore[no-untyped-def]
        year: int = Query(..., description="Year"),  # type: ignore[assignment]
        month: int = Query(..., description="Month (1-12)"),  # type: ignore[assignment]
        output_format: str = Query("json", description="Output format: json or image"),  # type: ignore[assignment]
        graph_type: str = Query("pie", description="Graph type: pie, bar, line, area"),  # type: ignore[assignment]
        image_size: str = Query("800x600", description="Image size (WxH)"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get monthly household data.

        Args:
            year: Year
            month: Month (1-12)
            output_format: Output format (json or image)
            graph_type: Graph type (pie, bar, line, area)
            image_size: Image size (WxH)

        Returns:
            Monthly data or image information

        """
        try:
            import os

            from household_mcp.dataloader import HouseholdDataLoader
            from household_mcp.tools.enhanced_tools import enhanced_monthly_summary

            data_dir = os.getenv("HOUSEHOLD_DATA_DIR", "data")

            if output_format == "image":
                # Generate image
                result = enhanced_monthly_summary(
                    year=year,
                    month=month,
                    output_format="image",
                    graph_type=graph_type,
                    image_size=image_size,
                )
                return result  # type: ignore[return-value]
            else:
                # Return JSON data
                loader = HouseholdDataLoader(src_dir=data_dir)
                df = loader.load_month(year, month)
                records = df.to_dict(orient="records")
                return {
                    "success": True,
                    "year": year,
                    "month": month,
                    "data": records,
                    "count": len(records),
                }
        except Exception as e:
            logger.exception(f"Error getting monthly data: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/available-months")
    async def get_available_months() -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get list of available months.

        Returns:
            List of available year-month combinations

        """
        try:
            import os

            from household_mcp.dataloader import HouseholdDataLoader

            data_dir = os.getenv("HOUSEHOLD_DATA_DIR", "data")
            loader = HouseholdDataLoader(src_dir=data_dir)
            months = [
                {"year": year, "month": month}
                for year, month in loader.iter_available_months()
            ]
            return {"success": True, "months": months}
        except Exception as e:
            logger.exception(f"Error getting available months: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/category-hierarchy")
    async def get_category_hierarchy(  # type: ignore[no-untyped-def]
        year: int = Query(2025, description="Year"),  # type: ignore[assignment]
        month: int = Query(1, description="Month"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get category hierarchy.

        Args:
            year: Year
            month: Month

        Returns:
            Category hierarchy

        """
        try:
            import os

            from household_mcp.dataloader import HouseholdDataLoader

            data_dir = os.getenv("HOUSEHOLD_DATA_DIR", "data")
            loader = HouseholdDataLoader(src_dir=data_dir)
            hierarchy = loader.category_hierarchy(year=year, month=month)
            return {"success": True, "hierarchy": dict(hierarchy)}
        except Exception as e:
            logger.exception(f"Error getting category hierarchy: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    # Duplicate detection endpoints
    @app.post("/api/duplicates/detect")
    async def detect_duplicates(  # type: ignore[no-untyped-def]
        date_tolerance_days: int = Query(0, description="Date tolerance in days"),  # type: ignore[assignment]
        amount_tolerance_abs: float = Query(
            0.0, description="Absolute amount tolerance"
        ),  # type: ignore[assignment]
        amount_tolerance_pct: float = Query(
            0.0, description="Percentage amount tolerance"
        ),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Detect duplicate transactions.

        Args:
            date_tolerance_days: Date tolerance in days (default: 0)
            amount_tolerance_abs: Absolute amount tolerance (default: 0.0)
            amount_tolerance_pct: Percentage amount tolerance (default: 0.0)

        Returns:
            Detection results with count

        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.detect_duplicates(
                date_tolerance_days=date_tolerance_days,
                amount_tolerance_abs=amount_tolerance_abs,
                amount_tolerance_pct=amount_tolerance_pct,
            )
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error detecting duplicates: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/duplicates/candidates")
    async def get_duplicate_candidates(  # type: ignore[no-untyped-def]
        limit: int = Query(10, description="Maximum number of candidates to return"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get list of duplicate candidates.

        Args:
            limit: Maximum number of candidates to return (default: 10)

        Returns:
            List of duplicate candidate pairs

        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.get_duplicate_candidates(limit=limit)
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error getting duplicate candidates: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/duplicates/{check_id}")
    async def get_duplicate_detail(check_id: int) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get details of a duplicate candidate.

        Args:
            check_id: Duplicate check ID

        Returns:
            Detailed information about the duplicate candidate

        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.get_duplicate_candidate_detail(check_id=check_id)
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error getting duplicate detail: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.post("/api/duplicates/{check_id}/confirm")
    async def confirm_duplicate(  # type: ignore[no-untyped-def]
        check_id: int,
        decision: str = Query(
            ..., description="Decision: duplicate, not_duplicate, or skip"
        ),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Confirm duplicate decision.

        Args:
            check_id: Duplicate check ID
            decision: Decision (duplicate, not_duplicate, or skip)

        Returns:
            Confirmation result

        """
        if decision not in ["duplicate", "not_duplicate", "skip"]:
            raise HTTPException(
                status_code=400,
                detail="Invalid decision. Must be 'duplicate', 'not_duplicate', or 'skip'",
            )

        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.confirm_duplicate(
                check_id=check_id,
                decision=decision,  # type: ignore[arg-type]
            )
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error confirming duplicate: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.post("/api/duplicates/restore/{transaction_id}")
    async def restore_duplicate(transaction_id: int) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Restore a transaction marked as duplicate.

        Args:
            transaction_id: Transaction ID to restore

        Returns:
            Restoration result

        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.restore_duplicate(transaction_id=transaction_id)
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error restoring duplicate: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/duplicates/stats")
    async def get_duplicate_stats() -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get duplicate detection statistics.

        Returns:
            Statistics about detected duplicates

        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.get_duplicate_stats()
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error getting duplicate stats: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    # Trend Analysis Endpoints (FR-019)
    @app.get("/api/trend/monthly_summary")
    async def get_monthly_summary(  # type: ignore[no-untyped-def]
        start_year: int = Query(..., description="Start year"),
        start_month: int = Query(..., ge=1, le=12, description="Start month (1-12)"),
        end_year: int = Query(..., description="End year"),
        end_month: int = Query(..., ge=1, le=12, description="End month (1-12)"),
    ) -> dict[str, Any]:
        """
        Get monthly income/expense summary for a date range.

        Args:
            start_year: Start year of the period
            start_month: Start month of the period (1-12)
            end_year: End year of the period
            end_month: End month of the period (1-12)

        Returns:
            Monthly summary data with income, expense, balance, and cumulative balance

        """
        try:
            from datetime import date

            from household_mcp.dataloader import HouseholdDataLoader

            # Validate date range
            start_date = date(start_year, start_month, 1)
            end_date = date(end_year, end_month, 1)

            if start_date > end_date:
                raise HTTPException(
                    status_code=400,
                    detail="Start date must be before or equal to end date",
                )

            # Load data for the entire period
            loader = HouseholdDataLoader()
            all_months = []

            current_year = start_year
            current_month = start_month

            while (current_year < end_year) or (
                current_year == end_year and current_month <= end_month
            ):
                all_months.append((current_year, current_month))
                current_month += 1
                if current_month > 12:
                    current_month = 1
                    current_year += 1

            # Aggregate monthly data
            monthly_data = []
            cumulative_balance = 0.0

            for year, month in all_months:
                try:
                    df = loader.load_month(year, month)

                    # Calculate income (positive amounts)
                    income = float(df[df["金額（円）"] > 0]["金額（円）"].sum())

                    # Calculate expense (negative amounts, shown as positive)
                    expense = float(abs(df[df["金額（円）"] < 0]["金額（円）"].sum()))

                    # Balance for the month
                    balance = income - expense
                    cumulative_balance += balance

                    monthly_data.append(
                        {
                            "year": year,
                            "month": month,
                            "year_month": f"{year}-{month:02d}",
                            "income": round(income, 2),
                            "expense": round(expense, 2),
                            "balance": round(balance, 2),
                            "cumulative_balance": round(cumulative_balance, 2),
                            "transaction_count": len(df),
                        }
                    )
                except FileNotFoundError:
                    # Month has no data, add zero entry
                    monthly_data.append(
                        {
                            "year": year,
                            "month": month,
                            "year_month": f"{year}-{month:02d}",
                            "income": 0.0,
                            "expense": 0.0,
                            "balance": 0.0,
                            "cumulative_balance": round(cumulative_balance, 2),
                            "transaction_count": 0,
                        }
                    )

            return {
                "success": True,
                "start_year": start_year,
                "start_month": start_month,
                "end_year": end_year,
                "end_month": end_month,
                "data": monthly_data,
            }

        except HTTPException:
            raise
        except Exception as e:
            logger.exception(f"Error getting monthly summary: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/trend/category_breakdown")
    async def get_category_breakdown(  # type: ignore[no-untyped-def]
        start_year: int = Query(..., description="Start year"),
        start_month: int = Query(..., ge=1, le=12, description="Start month (1-12)"),
        end_year: int = Query(..., description="End year"),
        end_month: int = Query(..., ge=1, le=12, description="End month (1-12)"),
        top_n: int = Query(5, ge=1, le=20, description="Number of top categories"),
    ) -> dict[str, Any]:
        """
        Get category breakdown trend for a date range.

        Args:
            start_year: Start year of the period
            start_month: Start month of the period (1-12)
            end_year: End year of the period
            end_month: End month of the period (1-12)
            top_n: Number of top categories to return (default: 5)

        Returns:
            Category breakdown data with monthly trends

        """
        try:
            from datetime import date

            import pandas as pd

            from household_mcp.dataloader import HouseholdDataLoader

            # Validate date range
            start_date = date(start_year, start_month, 1)
            end_date = date(end_year, end_month, 1)

            if start_date > end_date:
                raise HTTPException(
                    status_code=400,
                    detail="Start date must be before or equal to end date",
                )

            # Load data for the entire period
            loader = HouseholdDataLoader()
            all_months = []

            current_year = start_year
            current_month = start_month

            while (current_year < end_year) or (
                current_year == end_year and current_month <= end_month
            ):
                all_months.append((current_year, current_month))
                current_month += 1
                if current_month > 12:
                    current_month = 1
                    current_year += 1

            # Load all data and combine
            all_dfs = []
            for year, month in all_months:
                try:
                    df = loader.load_month(year, month)
                    df["year_month"] = f"{year}-{month:02d}"
                    all_dfs.append(df)
                except FileNotFoundError:
                    continue

            if not all_dfs:
                return {
                    "success": True,
                    "start_year": start_year,
                    "start_month": start_month,
                    "end_year": end_year,
                    "end_month": end_month,
                    "categories": [],
                    "months": [],
                    "data": [],
                }

            combined_df = pd.concat(all_dfs, ignore_index=True)

            # Filter expenses only (negative amounts)
            expense_df = combined_df[combined_df["金額（円）"] < 0].copy()
            expense_df["金額（円）"] = expense_df["金額（円）"].abs()

            # Find top N categories by total expense
            category_totals = (
                expense_df.groupby("大項目")["金額（円）"]
                .sum()
                .sort_values(ascending=False)
            )
            top_categories = category_totals.head(top_n).index.tolist()

            # Filter to top categories
            top_expense_df = expense_df[expense_df["大項目"].isin(top_categories)]

            # Aggregate by category and month
            category_monthly = (
                top_expense_df.groupby(["大項目", "year_month"])["金額（円）"]
                .sum()
                .reset_index()
            )

            # Pivot to get categories as columns
            pivot_data = category_monthly.pivot(
                index="year_month", columns="大項目", values="金額（円）"
            ).fillna(0)

            # Prepare response
            months = sorted(pivot_data.index.tolist())
            categories = top_categories

            # Convert to list of dicts for easier frontend consumption
            data = []
            for month in months:
                month_data = {"year_month": month}
                for category in categories:
                    month_data[category] = (
                        round(float(pivot_data.loc[month, category]), 2)
                        if category in pivot_data.columns
                        else 0.0
                    )
                data.append(month_data)

            return {
                "success": True,
                "start_year": start_year,
                "start_month": start_month,
                "end_year": end_year,
                "end_month": end_month,
                "categories": categories,
                "months": months,
                "data": data,
            }

        except HTTPException:
            raise
        except Exception as e:
            logger.exception(f"Error getting category breakdown: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    # Store cache and streamer as app state for external access
    app.state.chart_cache = chart_cache
    app.state.image_streamer = image_streamer

    # MCP Tool Definitions
    TOOL_DEFINITIONS = [
        {
            "name": "enhanced_monthly_summary",
            "display_name": "月別支出分析",
            "description": "指定された年月の収支データを取得し、カテゴリ別の分析を行います",
            "category": "analysis",
            "parameters": {
                "required": [
                    {
                        "name": "year",
                        "type": "integer",
                        "description": "年（例: 2024）",
                    },
                    {
                        "name": "month",
                        "type": "integer",
                        "description": "月（1-12）",
                    },
                ],
                "optional": [
                    {
                        "name": "output_format",
                        "type": "choice",
                        "description": "出力形式",
                        "choices": ["json", "csv"],
                    },
                ],
            },
        },
        {
            "name": "enhanced_category_trend",
            "display_name": "カテゴリ別推移分析",
            "description": "指定された期間のカテゴリ別支出推移を分析します",
            "category": "analysis",
            "parameters": {
                "required": [
                    {
                        "name": "category",
                        "type": "string",
                        "description": "カテゴリ名（例: 食費、交通費）",
                    },
                ],
                "optional": [
                    {
                        "name": "start_month",
                        "type": "string",
                        "description": "開始年月（YYYY-MM）",
                    },
                    {
                        "name": "end_month",
                        "type": "string",
                        "description": "終了年月（YYYY-MM）",
                    },
                ],
            },
        },
        {
            "name": "detect_duplicates",
            "display_name": "重複検出",
            "description": "指定された期間の重複する可能性のある取引を検出します",
            "category": "validation",
            "parameters": {
                "required": [
                    {
                        "name": "year",
                        "type": "integer",
                        "description": "年（例: 2024）",
                    },
                    {
                        "name": "month",
                        "type": "integer",
                        "description": "月（1-12）",
                    },
                ],
                "optional": [
                    {
                        "name": "date_tolerance_days",
                        "type": "integer",
                        "description": "日付の許容誤差（日数）",
                    },
                ],
            },
        },
        {
            "name": "get_duplicate_candidates",
            "display_name": "重複候補取得",
            "description": "重複の可能性がある取引候補を取得します",
            "category": "validation",
            "parameters": {
                "required": [],
                "optional": [
                    {
                        "name": "limit",
                        "type": "integer",
                        "description": "返す候補の最大数",
                    },
                ],
            },
        },
        {
            "name": "confirm_duplicate",
            "display_name": "重複確定",
            "description": "重複として確定された取引を記録します",
            "category": "validation",
            "parameters": {
                "required": [
                    {
                        "name": "transaction_id_1",
                        "type": "integer",
                        "description": "取引ID 1",
                    },
                    {
                        "name": "transaction_id_2",
                        "type": "integer",
                        "description": "取引ID 2",
                    },
                ],
                "optional": [],
            },
        },
    ]

    # ==================== Asset Management Endpoints ====================

    @app.get("/api/assets/classes")
    async def get_asset_classes() -> dict[str, Any]:  # type: ignore
        """
        Get all asset classes.

        Returns:
            List of asset classes with metadata

        """
        try:
            from household_mcp.assets.manager import AssetManager
            from household_mcp.database.manager import DatabaseManager

            db_manager = DatabaseManager()
            with db_manager.session_scope() as session:
                manager = AssetManager(session)
                classes = manager.get_asset_classes()
                return {
                    "success": True,
                    "data": classes,
                    "count": len(classes),
                }
        except Exception as e:
            logger.exception(f"Error getting asset classes: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/assets/records")
    async def get_asset_records(  # type: ignore
        asset_class_id: int | None = Query(
            None, description="Filter by asset class ID"
        ),  # type: ignore[assignment]
        start_date: str | None = Query(None, description="Start date (YYYY-MM-DD)"),  # type: ignore[assignment]
        end_date: str | None = Query(None, description="End date (YYYY-MM-DD)"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore
        """
        Get asset records with optional filtering.

        Args:
            asset_class_id: Filter by asset class ID
            start_date: Filter by start date
            end_date: Filter by end date

        Returns:
            List of asset records matching filters

        """
        try:
            from datetime import datetime as dt

            from household_mcp.assets.manager import AssetManager
            from household_mcp.database.manager import DatabaseManager

            db_manager = DatabaseManager()
            with db_manager.session_scope() as session:
                manager = AssetManager(session)

                # Parse dates if provided
                start_dt = None
                end_dt = None
                if start_date:
                    start_dt = dt.strptime(start_date, "%Y-%m-%d")
                if end_date:
                    end_dt = dt.strptime(end_date, "%Y-%m-%d")

                records = manager.get_records(
                    asset_class_id=asset_class_id,
                    start_date=start_dt,
                    end_date=end_dt,
                )
                return {
                    "success": True,
                    "data": [r.model_dump() for r in records],
                    "count": len(records),
                }
        except ValueError as e:
            raise HTTPException(status_code=400, detail=f"Invalid date format: {e!s}")
        except Exception as e:
            logger.exception(f"Error getting asset records: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.post("/api/assets/records")
    async def create_asset_record(  # type: ignore
        request_body: Any,  # type: ignore
    ) -> dict[str, Any]:  # type: ignore
        """
        Create a new asset record.

        Args:
            request_body: AssetRecordRequest with record data

        Returns:
            Created asset record with ID

        """
        try:
            from household_mcp.assets.manager import AssetManager
            from household_mcp.assets.models import AssetRecordRequest
            from household_mcp.database.manager import DatabaseManager

            # Parse request body into AssetRecordRequest
            if isinstance(request_body, dict):
                request = AssetRecordRequest(**request_body)
            else:
                request = request_body

            db_manager = DatabaseManager()
            with db_manager.session_scope() as session:
                manager = AssetManager(session)
                result = manager.create_record(request)
                return {
                    "success": True,
                    "data": result.model_dump(),
                }
        except Exception as e:
            logger.exception(f"Error creating asset record: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/assets/summary")
    async def get_asset_summary(  # type: ignore
        year: int = Query(..., description="Year"),  # type: ignore[assignment]
        month: int = Query(..., description="Month (1-12)"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore
        """
        Get asset summary for specified month.

        Args:
            year: Target year
            month: Target month (1-12)

        Returns:
            Asset class breakdown and total balance

        """
        try:
            from household_mcp.assets.manager import AssetManager
            from household_mcp.database.manager import DatabaseManager

            if not (1 <= month <= 12):
                raise HTTPException(
                    status_code=400, detail="Month must be between 1 and 12"
                )

            db_manager = DatabaseManager()
            with db_manager.session_scope() as session:
                manager = AssetManager(session)
                summary = manager.get_summary(year, month)
                return {
                    "success": True,
                    "data": summary,
                }
        except ValueError as e:
            raise HTTPException(status_code=400, detail=f"Invalid parameters: {e!s}")
        except Exception as e:
            logger.exception(f"Error getting asset summary: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/assets/allocation")
    async def get_asset_allocation(  # type: ignore
        year: int = Query(..., description="Year"),  # type: ignore[assignment]
        month: int = Query(..., description="Month (1-12)"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore
        """
        Get asset allocation for specified month.

        Args:
            year: Target year
            month: Target month (1-12)

        Returns:
            Asset allocation with percentages

        """
        try:
            from household_mcp.assets.manager import AssetManager
            from household_mcp.database.manager import DatabaseManager

            if not (1 <= month <= 12):
                raise HTTPException(
                    status_code=400, detail="Month must be between 1 and 12"
                )

            db_manager = DatabaseManager()
            with db_manager.session_scope() as session:
                manager = AssetManager(session)
                allocation = manager.get_allocation(year, month)
                return {
                    "success": True,
                    "data": allocation,
                }
        except ValueError as e:
            raise HTTPException(status_code=400, detail=f"Invalid parameters: {e!s}")
        except Exception as e:
            logger.exception(f"Error getting asset allocation: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.put("/api/assets/records/{record_id}")
    async def update_asset_record(  # type: ignore
        record_id: int,
        request_body: Any = None,  # type: ignore
    ) -> dict[str, Any]:  # type: ignore
        """
        Update an asset record.

        Args:
            record_id: Record ID to update
            request_body: AssetRecordRequest with updated data

        Returns:
            Updated asset record

        """
        try:
            from household_mcp.assets.manager import AssetManager
            from household_mcp.assets.models import AssetRecordRequest
            from household_mcp.database.manager import DatabaseManager

            if not request_body:
                msg = "Request body required"
                raise HTTPException(status_code=400, detail=msg)

            # Parse request body into AssetRecordRequest
            if isinstance(request_body, dict):
                request = AssetRecordRequest(**request_body)
            else:
                request = request_body

            db_manager = DatabaseManager()
            with db_manager.session_scope() as session:
                manager = AssetManager(session)
                try:
                    result = manager.update_record(record_id, request)
                    return {
                        "success": True,
                        "data": result.model_dump(),
                    }
                except ValueError:
                    msg = f"Record {record_id} not found"
                    raise HTTPException(status_code=404, detail=msg)
        except HTTPException:
            raise
        except Exception as e:
            logger.exception(f"Error updating asset record: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.delete("/api/assets/records/{record_id}")
    async def delete_asset_record(  # type: ignore
        record_id: int,
    ) -> dict[str, Any]:  # type: ignore
        """
        Delete (soft-delete) an asset record.

        Args:
            record_id: Record ID to delete

        Returns:
            Deletion result

        """
        try:
            from household_mcp.assets.manager import AssetManager
            from household_mcp.database.manager import DatabaseManager

            db_manager = DatabaseManager()
            with db_manager.session_scope() as session:
                manager = AssetManager(session)
                result = manager.delete_record(record_id)
                if not result:
                    msg = f"Record {record_id} not found"
                    raise HTTPException(status_code=404, detail=msg)
                return {
                    "success": True,
                    "message": f"Record {record_id} deleted successfully",
                }
        except HTTPException:
            raise
        except Exception as e:
            logger.exception(f"Error deleting asset record: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/assets/export")
    async def export_asset_records(  # type: ignore
        format_type: str = Query(  # type: ignore[assignment]
            "csv", description="Export format"
        ),
        asset_class_id: int | None = Query(  # type: ignore[assignment]
            None, description="Filter by asset class ID"
        ),
        start_date: str | None = Query(  # type: ignore[assignment]
            None, description="Start date (YYYY-MM-DD)"
        ),
        end_date: str | None = Query(  # type: ignore[assignment]
            None, description="End date (YYYY-MM-DD)"
        ),
    ) -> dict[str, Any]:  # type: ignore
        """
        Export asset records in specified format.

        Args:
            format_type: Export format (csv)
            asset_class_id: Filter by asset class ID
            start_date: Filter by start date
            end_date: Filter by end date

        Returns:
            CSV content as file download or JSON

        """
        try:
            from datetime import datetime as dt

            from fastapi.responses import Response

            from household_mcp.assets.manager import AssetManager
            from household_mcp.database.manager import DatabaseManager

            if format_type != "csv":
                msg = "Only 'csv' format is supported"
                raise HTTPException(status_code=400, detail=msg)

            # Parse dates if provided
            start_dt = None
            end_dt = None
            if start_date:
                start_dt = dt.strptime(start_date, "%Y-%m-%d")
            if end_date:
                end_dt = dt.strptime(end_date, "%Y-%m-%d")

            db_manager = DatabaseManager()
            with db_manager.session_scope() as session:
                manager = AssetManager(session)
                csv_content = manager.export_records_csv(
                    asset_class_id=asset_class_id,
                    start_date=start_dt,
                    end_date=end_dt,
                )

                # Return as downloadable CSV
                filename = "assets.csv"
                disposition = f"attachment; filename={filename}"
                return Response(
                    content=csv_content,
                    media_type="text/csv",
                    headers={"Content-Disposition": disposition},
                )  # type: ignore[return-value]

        except ValueError as e:
            msg = f"Invalid date format: {e!s}"
            raise HTTPException(status_code=400, detail=msg)
        except HTTPException:
            raise
        except Exception as e:
            logger.exception(f"Error exporting asset records: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    # ==================== Tools Endpoints ====================

    # ==================== Tools Endpoints ====================

    @app.get("/api/tools")
    async def list_tools() -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        List all available MCP tools.

        Returns:
            Dictionary with tools list

        """
        try:
            return {
                "success": True,
                "data": TOOL_DEFINITIONS,
            }
        except Exception as e:
            logger.exception(f"Error listing tools: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/tools/{tool_name}")
    async def get_tool(
        tool_name: str,
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get details for a specific tool.

        Args:
            tool_name: Name of the tool

        Returns:
            Dictionary with tool definition

        """
        try:
            tool = next(
                (t for t in TOOL_DEFINITIONS if t["name"] == tool_name),
                None,
            )
            if not tool:
                raise HTTPException(
                    status_code=404,
                    detail=f"Tool '{tool_name}' not found",
                )
            return {
                "success": True,
                "data": tool,
            }
        except HTTPException:
            raise
        except Exception as e:
            logger.exception(f"Error getting tool {tool_name}: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.post("/api/tools/{tool_name}/execute")
    async def execute_tool(  # type: ignore[no-untyped-def]
        tool_name: str,
        body: dict[str, Any] | None = None,
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Execute a specific MCP tool with given parameters.

        Args:
            tool_name: Name of the tool to execute
            body: Request body with tool parameters

        Returns:
            Dictionary with execution results

        """
        try:
            # Verify tool exists
            tool = next(
                (t for t in TOOL_DEFINITIONS if t["name"] == tool_name),
                None,
            )
            if not tool:
                raise HTTPException(
                    status_code=404,
                    detail=f"Tool '{tool_name}' not found",
                )

            # Get parameters from request body
            params = body or {}

            # Import and execute the appropriate tool
            if tool_name == "enhanced_monthly_summary":
                from household_mcp.tools.enhanced_tools import enhanced_monthly_summary

                result = enhanced_monthly_summary(**params)
            elif tool_name == "enhanced_category_trend":
                from household_mcp.tools.enhanced_tools import enhanced_category_trend

                result = enhanced_category_trend(**params)
            elif tool_name == "detect_duplicates":
                from household_mcp.tools.duplicate_tools import detect_duplicates

                result = detect_duplicates(**params)
            elif tool_name == "get_duplicate_candidates":
                from household_mcp.tools.duplicate_tools import get_duplicate_candidates

                result = get_duplicate_candidates(**params)
            elif tool_name == "confirm_duplicate":
                from household_mcp.tools.duplicate_tools import confirm_duplicate

                result = confirm_duplicate(**params)
            else:
                raise HTTPException(
                    status_code=400,
                    detail=f"Unknown tool: {tool_name}",
                )

            return {
                "success": True,
                "data": result,
            }

        except HTTPException:
            raise
        except TypeError as e:
            logger.exception(f"Invalid parameters for {tool_name}: {e}")
            raise HTTPException(
                status_code=400,
                detail=f"Invalid parameters: {e!s}",
            )
        except Exception as e:
            logger.exception(f"Error executing tool {tool_name}: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    # Include FIRE financial independence routes
    try:
        from household_mcp.web.routes import fi_router, transactions_router

        app.include_router(fi_router)
        app.include_router(transactions_router)
        logger.info("Included financial independence routes")
        logger.info("Included transaction CRUD routes")
    except ImportError as e:
        logger.warning(f"Could not import routes: {e}")

    return app
