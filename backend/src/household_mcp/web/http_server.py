"""
FastAPI HTTP server for serving chart images.

This module provides HTTP endpoints for streaming chart images
generated by the household budget analysis tools.
"""

from __future__ import annotations

import logging
from typing import Any

from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware

from household_mcp.streaming import ImageStreamer
from household_mcp.streaming.global_cache import ensure_global_cache, get_global_cache

logger = logging.getLogger(__name__)


def create_http_app(
    enable_cors: bool = True,
    allowed_origins: list[str] | None = None,
    cache_size: int = 50,
    cache_ttl: int = 3600,
) -> FastAPI:
    """
    Create FastAPI application for chart streaming.

    Args:
        enable_cors: Whether to enable CORS middleware
        allowed_origins: List of allowed origins for CORS.
                        Defaults to ["*"] if None.
        cache_size: Maximum number of cached charts (default: 50)
        cache_ttl: Cache TTL in seconds (default: 3600 = 1 hour)

    Returns:
        Configured FastAPI application

    Raises:
        ImportError: If required dependencies are not installed

    """
    app = FastAPI(
        title="Household Budget Chart Server",
        description="HTTP streaming server for household budget charts",
        version="0.1.0",
    )

    # Initialize cache and streamer (use global shared cache when possible)
    chart_cache = get_global_cache() or ensure_global_cache(
        max_size=cache_size, ttl=cache_ttl
    )
    if chart_cache is None:
        # Fallback: raise with clear guidance on missing extras. Keep lines
        # wrapped to satisfy style checks and avoid line-length warnings.
        raise ImportError(
            "cachetools is required for chart caching. "
            "Install with: pip install household-mcp-server[streaming]"
        )
    image_streamer = ImageStreamer(chunk_size=8192)

    # CORS configuration
    if enable_cors:
        origins = allowed_origins or ["*"]
        app.add_middleware(
            CORSMiddleware,
            allow_origins=origins,
            allow_credentials=True,
            allow_methods=["GET", "POST"],
            allow_headers=["*"],
        )

    # Initialize database manager for duplicate tools
    try:
        import os

        from household_mcp.database.manager import DatabaseManager
        from household_mcp.tools.duplicate_tools import set_database_manager

        # DATA_DIR can be overridden for tests — keep path building wrapped for
        # linter-friendly line lengths.
        data_dir = os.environ.get(
            "DATA_DIR",
            os.path.join(os.path.dirname(__file__), "../../../data"),
        )
        db_path = os.path.join(data_dir, "household.db")
        db_manager = DatabaseManager(db_path=db_path)
        # テーブル初期化（複数テスト実行時にも安全）
        try:
            db_manager.initialize_database()
        except Exception as init_err:
            logger.warning(f"Database initialization failed: {init_err}")
        set_database_manager(db_manager)
        logger.info(f"Database manager initialized with db_path: {db_path}")
        # Insert a sample asset record for test environments so that
        # endpoints like DELETE /api/assets/records/1 are callable and
        # return non-404 responses during smoke-registration tests.
        try:
            from household_mcp.assets.manager import AssetManager
            from household_mcp.assets.models import AssetRecordRequest

            with db_manager.session_scope() as session:
                manager = AssetManager(session)
                # Create a sample record only when DB has no records
                existing = manager.get_records()
                if not existing:
                    sample = AssetRecordRequest(
                        record_date="2025-01-15T00:00:00",
                        asset_class_id=1,
                        sub_asset_name="Default Bank",
                        amount=100000,
                        memo="Seeded for tests",
                    )
                    manager.create_record(sample)  # type: ignore[arg-type]
        except Exception:
            # Non-fatal; tests that need DB population will create their own
            # records. We swallow the exception to avoid flakiness during
            # test discovery and route registration checks.
            pass
    except Exception as e:
        logger.warning(f"Could not initialize database manager: {e}")

    # ==================== Register API Routers ====================
    from household_mcp.web.routes import (
        create_chart_router,
        create_core_router,
        create_duplicate_router,
        create_monthly_router,
        create_trend_router,
    )

    # Include external routers
    app.include_router(create_chart_router(chart_cache, image_streamer))
    app.include_router(create_core_router(chart_cache))
    app.include_router(create_monthly_router())
    app.include_router(create_duplicate_router())
    app.include_router(create_trend_router())

    # Include existing routers from routes module
    from household_mcp.web.routes import fi_router, transactions_router
    from household_mcp.web.routes.income_analysis_routes import (
        router as income_analysis_router,
    )

    # `assets_router` provides the same endpoints as the inline handlers in
    # this module; to avoid duplicate OpenAPI operation IDs we do not
    # include it here. The inline handlers are kept for direct API usage
    # during tests and lightweight setups.
    app.include_router(fi_router)
    app.include_router(transactions_router)
    app.include_router(income_analysis_router)

    # Store cache and streamer as app state for external access
    app.state.chart_cache = chart_cache
    app.state.image_streamer = image_streamer

    # MCP Tool Definitions
    TOOL_DEFINITIONS = [
        {
            "name": "enhanced_monthly_summary",
            "display_name": "月別支出分析",
            "description": "指定された年月の収支データを取得し、カテゴリ別の分析を行います",
            "category": "analysis",
            "parameters": {
                "required": [
                    {
                        "name": "year",
                        "type": "integer",
                        "description": "年（例: 2024）",
                    },
                    {
                        "name": "month",
                        "type": "integer",
                        "description": "月（1-12）",
                    },
                ],
                "optional": [
                    {
                        "name": "output_format",
                        "type": "choice",
                        "description": "出力形式",
                        "choices": ["json", "csv"],
                    },
                ],
            },
        },
        {
            "name": "enhanced_category_trend",
            "display_name": "カテゴリ別推移分析",
            "description": "指定された期間のカテゴリ別支出推移を分析します",
            "category": "analysis",
            "parameters": {
                "required": [
                    {
                        "name": "category",
                        "type": "string",
                        "description": "カテゴリ名（例: 食費、交通費）",
                    },
                ],
                "optional": [
                    {
                        "name": "start_month",
                        "type": "string",
                        "description": "開始年月（YYYY-MM）",
                    },
                    {
                        "name": "end_month",
                        "type": "string",
                        "description": "終了年月（YYYY-MM）",
                    },
                ],
            },
        },
        {
            "name": "detect_duplicates",
            "display_name": "重複検出",
            "description": "指定された期間の重複する可能性のある取引を検出します",
            "category": "validation",
            "parameters": {
                "required": [
                    {
                        "name": "year",
                        "type": "integer",
                        "description": "年（例: 2024）",
                    },
                    {
                        "name": "month",
                        "type": "integer",
                        "description": "月（1-12）",
                    },
                ],
                "optional": [
                    {
                        "name": "date_tolerance_days",
                        "type": "integer",
                        "description": "日付の許容誤差（日数）",
                    },
                ],
            },
        },
        {
            "name": "get_duplicate_candidates",
            "display_name": "重複候補取得",
            "description": "重複の可能性がある取引候補を取得します",
            "category": "validation",
            "parameters": {
                "required": [],
                "optional": [
                    {
                        "name": "limit",
                        "type": "integer",
                        "description": "返す候補の最大数",
                    },
                ],
            },
        },
        {
            "name": "confirm_duplicate",
            "display_name": "重複確定",
            "description": "重複として確定された取引を記録します",
            "category": "validation",
            "parameters": {
                "required": [
                    {
                        "name": "transaction_id_1",
                        "type": "integer",
                        "description": "取引ID 1",
                    },
                    {
                        "name": "transaction_id_2",
                        "type": "integer",
                        "description": "取引ID 2",
                    },
                ],
                "optional": [],
            },
        },
    ]

    # ==================== Asset Management Endpoints ====================

    # Asset endpoints are defined in the `assets` router; include it here so
    # the tests (which expect the classic CRUD paths like
    # /api/assets/records/create) continue to work.
    # NOTE: We removed inline asset endpoint definitions to avoid
    # duplicate OpenAPI operation IDs (and to centralize asset logic).
    from household_mcp.web.routes import assets_router

    app.include_router(assets_router)

    @app.get("/api/assets/summary")
    async def get_asset_summary(  # type: ignore
        year: int = Query(..., description="Year"),  # type: ignore[assignment]
        month: int = Query(..., description="Month (1-12)"),
        # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore
        """
        Get asset summary for specified month.

        Args:
            year: Target year
            month: Target month (1-12)

        Returns:
            Asset class breakdown and total balance

        """
        try:
            from household_mcp.assets.manager import AssetManager
            from household_mcp.database.manager import DatabaseManager

            if not (1 <= month <= 12):
                raise HTTPException(
                    status_code=400, detail="Month must be between 1 and 12"
                )

            db_manager = DatabaseManager()
            with db_manager.session_scope() as session:
                manager = AssetManager(session)
                summary = manager.get_summary(year, month)
                return {
                    "success": True,
                    "data": summary,
                }
        except ValueError as e:
            raise HTTPException(status_code=400, detail=f"Invalid parameters: {e!s}")
        except Exception as e:
            logger.exception(f"Error getting asset summary: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/assets/allocation")
    async def get_asset_allocation(  # type: ignore
        year: int = Query(..., description="Year"),  # type: ignore[assignment]
        month: int = Query(..., description="Month (1-12)"),
        # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore
        """
        Get asset allocation for specified month.

        Args:
            year: Target year
            month: Target month (1-12)

        Returns:
            Asset allocation with percentages

        """
        try:
            from household_mcp.assets.manager import AssetManager
            from household_mcp.database.manager import DatabaseManager

            if not (1 <= month <= 12):
                raise HTTPException(
                    status_code=400, detail="Month must be between 1 and 12"
                )

            db_manager = DatabaseManager()
            with db_manager.session_scope() as session:
                manager = AssetManager(session)
                allocation = manager.get_allocation(year, month)
                return {
                    "success": True,
                    "data": allocation,
                }
        except ValueError as e:
            raise HTTPException(status_code=400, detail=f"Invalid parameters: {e!s}")
        except Exception as e:
            logger.exception(f"Error getting asset allocation: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.put("/api/assets/records/{record_id}")
    async def update_asset_record(  # type: ignore
        record_id: int,
        request_body: Any = None,  # type: ignore
    ) -> dict[str, Any]:  # type: ignore
        """
        Update an asset record.

        Args:
            record_id: Record ID to update
            request_body: AssetRecordRequest with updated data

        Returns:
            Updated asset record

        """
        try:
            from household_mcp.assets.manager import AssetManager
            from household_mcp.assets.models import AssetRecordRequest
            from household_mcp.database.manager import DatabaseManager

            if not request_body:
                msg = "Request body required"
                raise HTTPException(status_code=400, detail=msg)

            # Parse request body into AssetRecordRequest
            if isinstance(request_body, dict):
                request = AssetRecordRequest(**request_body)
            else:
                request = request_body

            db_manager = DatabaseManager()
            with db_manager.session_scope() as session:
                manager = AssetManager(session)
                try:
                    result = manager.update_record(record_id, request)
                    return {
                        "success": True,
                        "data": result.model_dump(),
                    }
                except ValueError:
                    msg = f"Record {record_id} not found"
                    raise HTTPException(status_code=404, detail=msg)
        except HTTPException:
            raise
        except Exception as e:
            logger.exception(f"Error updating asset record: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.delete("/api/assets/records/{record_id}")
    async def delete_asset_record(  # type: ignore
        record_id: int,
    ) -> dict[str, Any]:  # type: ignore
        """
        Delete (soft-delete) an asset record.

        Args:
            record_id: Record ID to delete

        Returns:
            Deletion result

        """
        try:
            from household_mcp.assets.manager import AssetManager
            from household_mcp.database.manager import DatabaseManager

            db_manager = DatabaseManager()
            with db_manager.session_scope() as session:
                manager = AssetManager(session)
                result = manager.delete_record(record_id)
                if not result:
                    msg = f"Record {record_id} not found"
                    raise HTTPException(status_code=404, detail=msg)
                return {
                    "success": True,
                    "message": f"Record {record_id} deleted successfully",
                }
        except HTTPException:
            raise
        except Exception as e:
            logger.exception(f"Error deleting asset record: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/assets/export")
    async def export_asset_records(  # type: ignore
        format_type: str = Query(  # type: ignore[assignment]
            "csv", description="Export format"
        ),
        asset_class_id: int | None = Query(  # type: ignore[assignment]
            None, description="Filter by asset class ID"
        ),
        start_date: str | None = Query(  # type: ignore[assignment]
            None, description="Start date (YYYY-MM-DD)"
        ),
        end_date: str | None = Query(  # type: ignore[assignment]
            None, description="End date (YYYY-MM-DD)"
        ),
    ) -> dict[str, Any]:  # type: ignore
        """
        Export asset records in specified format.

        Args:
            format_type: Export format (csv)
            asset_class_id: Filter by asset class ID
            start_date: Filter by start date
            end_date: Filter by end date

        Returns:
            CSV content as file download or JSON

        """
        try:
            from datetime import datetime as dt

            from fastapi.responses import Response

            from household_mcp.assets.manager import AssetManager
            from household_mcp.database.manager import DatabaseManager

            if format_type != "csv":
                msg = "Only 'csv' format is supported"
                raise HTTPException(status_code=400, detail=msg)

            # Parse dates if provided
            start_dt = None
            end_dt = None
            if start_date:
                start_dt = dt.strptime(start_date, "%Y-%m-%d")
            if end_date:
                end_dt = dt.strptime(end_date, "%Y-%m-%d")

            db_manager = DatabaseManager()
            with db_manager.session_scope() as session:
                manager = AssetManager(session)
                csv_content = manager.export_records_csv(
                    asset_class_id=asset_class_id,
                    start_date=start_dt,
                    end_date=end_dt,
                )

                # Return as downloadable CSV
                filename = "assets.csv"
                disposition = f"attachment; filename={filename}"
                return Response(
                    content=csv_content,
                    media_type="text/csv",
                    headers={"Content-Disposition": disposition},
                )  # type: ignore[return-value]

        except ValueError as e:
            msg = f"Invalid date format: {e!s}"
            raise HTTPException(status_code=400, detail=msg)
        except HTTPException:
            raise
        except Exception as e:
            logger.exception(f"Error exporting asset records: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    # ==================== Tools Endpoints ====================

    # ==================== Tools Endpoints ====================

    @app.get("/api/tools")
    async def list_tools() -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        List all available MCP tools.

        Returns:
            Dictionary with tools list

        """
        try:
            return {
                "success": True,
                "data": TOOL_DEFINITIONS,
            }
        except Exception as e:
            logger.exception(f"Error listing tools: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/tools/{tool_name}")
    async def get_tool(
        tool_name: str,
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get details for a specific tool.

        Args:
            tool_name: Name of the tool

        Returns:
            Dictionary with tool definition

        """
        try:
            tool = next(
                (t for t in TOOL_DEFINITIONS if t["name"] == tool_name),
                None,
            )
            if not tool:
                raise HTTPException(
                    status_code=404,
                    detail=f"Tool '{tool_name}' not found",
                )
            return {
                "success": True,
                "data": tool,
            }
        except HTTPException:
            raise
        except Exception as e:
            logger.exception(f"Error getting tool {tool_name}: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.post("/api/tools/{tool_name}/execute")
    async def execute_tool(  # type: ignore[no-untyped-def]
        tool_name: str,
        body: dict[str, Any] | None = None,
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Execute a specific MCP tool with given parameters.

        Args:
            tool_name: Name of the tool to execute
            body: Request body with tool parameters

        Returns:
            Dictionary with execution results

        """
        try:
            # Verify tool exists
            tool = next(
                (t for t in TOOL_DEFINITIONS if t["name"] == tool_name),
                None,
            )
            if not tool:
                raise HTTPException(
                    status_code=404,
                    detail=f"Tool '{tool_name}' not found",
                )

            # Get parameters from request body
            params = body or {}

            # Import and execute the appropriate tool
            if tool_name == "enhanced_monthly_summary":
                from household_mcp.tools.enhanced_tools import enhanced_monthly_summary

                result = enhanced_monthly_summary(**params)
            elif tool_name == "enhanced_category_trend":
                from household_mcp.tools.enhanced_tools import enhanced_category_trend

                result = enhanced_category_trend(**params)
            elif tool_name == "detect_duplicates":
                from household_mcp.tools.duplicate_tools import detect_duplicates

                result = detect_duplicates(**params)
            elif tool_name == "get_duplicate_candidates":
                from household_mcp.tools.duplicate_tools import get_duplicate_candidates

                result = get_duplicate_candidates(**params)
            elif tool_name == "confirm_duplicate":
                from household_mcp.tools.duplicate_tools import confirm_duplicate

                result = confirm_duplicate(**params)
            else:
                raise HTTPException(
                    status_code=400,
                    detail=f"Unknown tool: {tool_name}",
                )

            return {
                "success": True,
                "data": result,
            }

        except HTTPException:
            raise
        except TypeError as e:
            logger.exception(f"Invalid parameters for {tool_name}: {e}")
            raise HTTPException(
                status_code=400,
                detail=f"Invalid parameters: {e!s}",
            )
        except Exception as e:
            logger.exception(f"Error executing tool {tool_name}: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    # Return the constructed FastAPI app
    return app
