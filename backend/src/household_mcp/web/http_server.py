"""
FastAPI HTTP server for serving chart images.

This module provides HTTP endpoints for streaming chart images
generated by the household budget analysis tools.
"""

from __future__ import annotations

import logging
from typing import Any

try:
    from fastapi import FastAPI, HTTPException, Query
    from fastapi.middleware.cors import CORSMiddleware
    from fastapi.responses import StreamingResponse

    HAS_FASTAPI = True
except ImportError:
    HAS_FASTAPI = False

from household_mcp.streaming import ImageStreamer
from household_mcp.streaming.global_cache import ensure_global_cache, get_global_cache

logger = logging.getLogger(__name__)


def create_http_app(
    enable_cors: bool = True,
    allowed_origins: list[str] | None = None,
    cache_size: int = 50,
    cache_ttl: int = 3600,
) -> FastAPI:
    """
    Create FastAPI application for chart streaming.

    Args:
        enable_cors: Whether to enable CORS middleware
        allowed_origins: List of allowed origins for CORS.
                        Defaults to ["*"] if None.
        cache_size: Maximum number of cached charts (default: 50)
        cache_ttl: Cache TTL in seconds (default: 3600 = 1 hour)

    Returns:
        Configured FastAPI application

    Raises:
        ImportError: If FastAPI is not installed

    """
    if not HAS_FASTAPI:
        raise ImportError(
            "FastAPI is required for HTTP server. "
            "Install with: pip install household-mcp-server[streaming]"
        )

    app = FastAPI(
        title="Household Budget Chart Server",
        description="HTTP streaming server for household budget charts",
        version="0.1.0",
    )

    # Initialize cache and streamer (use global shared cache when possible)
    chart_cache = get_global_cache() or ensure_global_cache(
        max_size=cache_size, ttl=cache_ttl
    )
    if chart_cache is None:
        # Fallback: raise with clear guidance on missing extras
        raise ImportError(
            "cachetools is required for chart caching. "
            "Install with: pip install household-mcp-server[streaming]"
        )
    image_streamer = ImageStreamer(chunk_size=8192)

    # CORS configuration
    if enable_cors:
        origins = allowed_origins or ["*"]
        app.add_middleware(
            CORSMiddleware,
            allow_origins=origins,
            allow_credentials=True,
            allow_methods=["GET"],
            allow_headers=["*"],
        )

    @app.get("/api/charts/{chart_id}")
    async def stream_chart(chart_id: str) -> StreamingResponse:  # type: ignore[no-untyped-def]
        """
        Stream a generated chart image.

        Args:
            chart_id: Unique identifier for the chart (cache key)

        Returns:
            StreamingResponse with image data

        Raises:
            HTTPException: If chart not found in cache (404)

        """
        logger.info(f"Request for chart: {chart_id}")

        # Retrieve from cache
        image_data = chart_cache.get(chart_id)
        if image_data is None:
            logger.warning(f"Chart not found: {chart_id}")
            raise HTTPException(status_code=404, detail=f"Chart '{chart_id}' not found")

        # Stream the image
        logger.info(f"Streaming chart: {chart_id} ({len(image_data)} bytes)")
        return image_streamer.create_response(
            image_data,
            media_type="image/png",
            filename=f"chart_{chart_id}.png",
        )

    @app.get("/api/charts/{chart_id}/info")
    async def get_chart_info(chart_id: str) -> dict[str, object]:  # type: ignore[no-untyped-def]
        """
        Get information about a cached chart.

        Args:
            chart_id: Unique identifier for the chart

        Returns:
            Dictionary with chart metadata

        Raises:
            HTTPException: If chart not found in cache (404)

        """
        image_data = chart_cache.get(chart_id)
        if image_data is None:
            raise HTTPException(status_code=404, detail=f"Chart '{chart_id}' not found")

        return {
            "chart_id": chart_id,
            "size_bytes": len(image_data),
            "media_type": "image/png",
        }

    @app.get("/api/cache/stats")
    async def get_cache_stats() -> dict[str, object]:  # type: ignore[no-untyped-def]
        """
        Get cache statistics.

        Returns:
            Dictionary with cache statistics

        """
        return chart_cache.stats()

    @app.delete("/api/cache")
    async def clear_cache() -> dict[str, object]:  # type: ignore[no-untyped-def]
        """
        Clear all cached charts.

        Returns:
            Confirmation message

        """
        chart_cache.clear()
        logger.info("Cache cleared")
        return {"status": "success", "message": "Cache cleared"}

    @app.get("/health")
    async def health_check() -> dict[str, object]:  # type: ignore[no-untyped-def]
        """
        Health check endpoint.

        Returns:
            Health status

        """
        return {"status": "healthy", "cache_size": chart_cache.size()}

    # MCP Tool API endpoints
    @app.get("/api/monthly")
    async def get_monthly_data(  # type: ignore[no-untyped-def]
        year: int = Query(..., description="Year"),  # type: ignore[assignment]
        month: int = Query(..., description="Month (1-12)"),  # type: ignore[assignment]
        output_format: str = Query("json", description="Output format: json or image"),  # type: ignore[assignment]
        graph_type: str = Query("pie", description="Graph type: pie, bar, line, area"),  # type: ignore[assignment]
        image_size: str = Query("800x600", description="Image size (WxH)"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get monthly household data.

        Args:
            year: Year
            month: Month (1-12)
            output_format: Output format (json or image)
            graph_type: Graph type (pie, bar, line, area)
            image_size: Image size (WxH)

        Returns:
            Monthly data or image information

        """
        try:
            import os

            from household_mcp.dataloader import HouseholdDataLoader
            from household_mcp.tools.enhanced_tools import enhanced_monthly_summary

            data_dir = os.getenv("HOUSEHOLD_DATA_DIR", "data")

            if output_format == "image":
                # Generate image
                result = enhanced_monthly_summary(
                    year=year,
                    month=month,
                    output_format="image",
                    graph_type=graph_type,
                    image_size=image_size,
                )
                return result  # type: ignore[return-value]
            else:
                # Return JSON data
                loader = HouseholdDataLoader(src_dir=data_dir)
                df = loader.load_month(year, month)
                records = df.to_dict(orient="records")
                return {
                    "success": True,
                    "year": year,
                    "month": month,
                    "data": records,
                    "count": len(records),
                }
        except Exception as e:
            logger.exception(f"Error getting monthly data: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/available-months")
    async def get_available_months() -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get list of available months.

        Returns:
            List of available year-month combinations

        """
        try:
            import os

            from household_mcp.dataloader import HouseholdDataLoader

            data_dir = os.getenv("HOUSEHOLD_DATA_DIR", "data")
            loader = HouseholdDataLoader(src_dir=data_dir)
            months = [
                {"year": year, "month": month}
                for year, month in loader.iter_available_months()
            ]
            return {"success": True, "months": months}
        except Exception as e:
            logger.exception(f"Error getting available months: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/category-hierarchy")
    async def get_category_hierarchy(  # type: ignore[no-untyped-def]
        year: int = Query(2025, description="Year"),  # type: ignore[assignment]
        month: int = Query(1, description="Month"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get category hierarchy.

        Args:
            year: Year
            month: Month

        Returns:
            Category hierarchy

        """
        try:
            import os

            from household_mcp.dataloader import HouseholdDataLoader

            data_dir = os.getenv("HOUSEHOLD_DATA_DIR", "data")
            loader = HouseholdDataLoader(src_dir=data_dir)
            hierarchy = loader.category_hierarchy(year=year, month=month)
            return {"success": True, "hierarchy": dict(hierarchy)}
        except Exception as e:
            logger.exception(f"Error getting category hierarchy: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    # Duplicate detection endpoints
    @app.post("/api/duplicates/detect")
    async def detect_duplicates(  # type: ignore[no-untyped-def]
        date_tolerance_days: int = Query(0, description="Date tolerance in days"),  # type: ignore[assignment]
        amount_tolerance_abs: float = Query(
            0.0, description="Absolute amount tolerance"
        ),  # type: ignore[assignment]
        amount_tolerance_pct: float = Query(
            0.0, description="Percentage amount tolerance"
        ),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Detect duplicate transactions.

        Args:
            date_tolerance_days: Date tolerance in days (default: 0)
            amount_tolerance_abs: Absolute amount tolerance (default: 0.0)
            amount_tolerance_pct: Percentage amount tolerance (default: 0.0)

        Returns:
            Detection results with count

        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.detect_duplicates(
                date_tolerance_days=date_tolerance_days,
                amount_tolerance_abs=amount_tolerance_abs,
                amount_tolerance_pct=amount_tolerance_pct,
            )
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error detecting duplicates: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/duplicates/candidates")
    async def get_duplicate_candidates(  # type: ignore[no-untyped-def]
        limit: int = Query(10, description="Maximum number of candidates to return"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get list of duplicate candidates.

        Args:
            limit: Maximum number of candidates to return (default: 10)

        Returns:
            List of duplicate candidate pairs

        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.get_duplicate_candidates(limit=limit)
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error getting duplicate candidates: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/duplicates/{check_id}")
    async def get_duplicate_detail(check_id: int) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get details of a duplicate candidate.

        Args:
            check_id: Duplicate check ID

        Returns:
            Detailed information about the duplicate candidate

        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.get_duplicate_candidate_detail(check_id=check_id)
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error getting duplicate detail: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.post("/api/duplicates/{check_id}/confirm")
    async def confirm_duplicate(  # type: ignore[no-untyped-def]
        check_id: int,
        decision: str = Query(
            ..., description="Decision: duplicate, not_duplicate, or skip"
        ),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Confirm duplicate decision.

        Args:
            check_id: Duplicate check ID
            decision: Decision (duplicate, not_duplicate, or skip)

        Returns:
            Confirmation result

        """
        if decision not in ["duplicate", "not_duplicate", "skip"]:
            raise HTTPException(
                status_code=400,
                detail="Invalid decision. Must be 'duplicate', 'not_duplicate', or 'skip'",
            )

        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.confirm_duplicate(
                check_id=check_id,
                decision=decision,  # type: ignore[arg-type]
            )
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error confirming duplicate: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.post("/api/duplicates/restore/{transaction_id}")
    async def restore_duplicate(transaction_id: int) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Restore a transaction marked as duplicate.

        Args:
            transaction_id: Transaction ID to restore

        Returns:
            Restoration result

        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.restore_duplicate(transaction_id=transaction_id)
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error restoring duplicate: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/duplicates/stats")
    async def get_duplicate_stats() -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """
        Get duplicate detection statistics.

        Returns:
            Statistics about detected duplicates

        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.get_duplicate_stats()
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error getting duplicate stats: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    # Trend Analysis Endpoints (FR-019)
    @app.get("/api/trend/monthly_summary")
    async def get_monthly_summary(  # type: ignore[no-untyped-def]
        start_year: int = Query(..., description="Start year"),
        start_month: int = Query(..., ge=1, le=12, description="Start month (1-12)"),
        end_year: int = Query(..., description="End year"),
        end_month: int = Query(..., ge=1, le=12, description="End month (1-12)"),
    ) -> dict[str, Any]:
        """
        Get monthly income/expense summary for a date range.

        Args:
            start_year: Start year of the period
            start_month: Start month of the period (1-12)
            end_year: End year of the period
            end_month: End month of the period (1-12)

        Returns:
            Monthly summary data with income, expense, balance, and cumulative balance

        """
        try:
            from datetime import date

            from household_mcp.dataloader import HouseholdDataLoader

            # Validate date range
            start_date = date(start_year, start_month, 1)
            end_date = date(end_year, end_month, 1)

            if start_date > end_date:
                raise HTTPException(
                    status_code=400,
                    detail="Start date must be before or equal to end date",
                )

            # Load data for the entire period
            loader = HouseholdDataLoader()
            all_months = []

            current_year = start_year
            current_month = start_month

            while (current_year < end_year) or (
                current_year == end_year and current_month <= end_month
            ):
                all_months.append((current_year, current_month))
                current_month += 1
                if current_month > 12:
                    current_month = 1
                    current_year += 1

            # Aggregate monthly data
            monthly_data = []
            cumulative_balance = 0.0

            for year, month in all_months:
                try:
                    df = loader.load_month(year, month)

                    # Calculate income (positive amounts)
                    income = float(df[df["金額（円）"] > 0]["金額（円）"].sum())

                    # Calculate expense (negative amounts, shown as positive)
                    expense = float(abs(df[df["金額（円）"] < 0]["金額（円）"].sum()))

                    # Balance for the month
                    balance = income - expense
                    cumulative_balance += balance

                    monthly_data.append(
                        {
                            "year": year,
                            "month": month,
                            "year_month": f"{year}-{month:02d}",
                            "income": round(income, 2),
                            "expense": round(expense, 2),
                            "balance": round(balance, 2),
                            "cumulative_balance": round(cumulative_balance, 2),
                            "transaction_count": len(df),
                        }
                    )
                except FileNotFoundError:
                    # Month has no data, add zero entry
                    monthly_data.append(
                        {
                            "year": year,
                            "month": month,
                            "year_month": f"{year}-{month:02d}",
                            "income": 0.0,
                            "expense": 0.0,
                            "balance": 0.0,
                            "cumulative_balance": round(cumulative_balance, 2),
                            "transaction_count": 0,
                        }
                    )

            return {
                "success": True,
                "start_year": start_year,
                "start_month": start_month,
                "end_year": end_year,
                "end_month": end_month,
                "data": monthly_data,
            }

        except HTTPException:
            raise
        except Exception as e:
            logger.exception(f"Error getting monthly summary: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/trend/category_breakdown")
    async def get_category_breakdown(  # type: ignore[no-untyped-def]
        start_year: int = Query(..., description="Start year"),
        start_month: int = Query(..., ge=1, le=12, description="Start month (1-12)"),
        end_year: int = Query(..., description="End year"),
        end_month: int = Query(..., ge=1, le=12, description="End month (1-12)"),
        top_n: int = Query(5, ge=1, le=20, description="Number of top categories"),
    ) -> dict[str, Any]:
        """
        Get category breakdown trend for a date range.

        Args:
            start_year: Start year of the period
            start_month: Start month of the period (1-12)
            end_year: End year of the period
            end_month: End month of the period (1-12)
            top_n: Number of top categories to return (default: 5)

        Returns:
            Category breakdown data with monthly trends

        """
        try:
            from datetime import date

            import pandas as pd

            from household_mcp.dataloader import HouseholdDataLoader

            # Validate date range
            start_date = date(start_year, start_month, 1)
            end_date = date(end_year, end_month, 1)

            if start_date > end_date:
                raise HTTPException(
                    status_code=400,
                    detail="Start date must be before or equal to end date",
                )

            # Load data for the entire period
            loader = HouseholdDataLoader()
            all_months = []

            current_year = start_year
            current_month = start_month

            while (current_year < end_year) or (
                current_year == end_year and current_month <= end_month
            ):
                all_months.append((current_year, current_month))
                current_month += 1
                if current_month > 12:
                    current_month = 1
                    current_year += 1

            # Load all data and combine
            all_dfs = []
            for year, month in all_months:
                try:
                    df = loader.load_month(year, month)
                    df["year_month"] = f"{year}-{month:02d}"
                    all_dfs.append(df)
                except FileNotFoundError:
                    continue

            if not all_dfs:
                return {
                    "success": True,
                    "start_year": start_year,
                    "start_month": start_month,
                    "end_year": end_year,
                    "end_month": end_month,
                    "categories": [],
                    "months": [],
                    "data": [],
                }

            combined_df = pd.concat(all_dfs, ignore_index=True)

            # Filter expenses only (negative amounts)
            expense_df = combined_df[combined_df["金額（円）"] < 0].copy()
            expense_df["金額（円）"] = expense_df["金額（円）"].abs()

            # Find top N categories by total expense
            category_totals = (
                expense_df.groupby("大項目")["金額（円）"]
                .sum()
                .sort_values(ascending=False)
            )
            top_categories = category_totals.head(top_n).index.tolist()

            # Filter to top categories
            top_expense_df = expense_df[expense_df["大項目"].isin(top_categories)]

            # Aggregate by category and month
            category_monthly = (
                top_expense_df.groupby(["大項目", "year_month"])["金額（円）"]
                .sum()
                .reset_index()
            )

            # Pivot to get categories as columns
            pivot_data = category_monthly.pivot(
                index="year_month", columns="大項目", values="金額（円）"
            ).fillna(0)

            # Prepare response
            months = sorted(pivot_data.index.tolist())
            categories = top_categories

            # Convert to list of dicts for easier frontend consumption
            data = []
            for month in months:
                month_data = {"year_month": month}
                for category in categories:
                    month_data[category] = (
                        round(float(pivot_data.loc[month, category]), 2)
                        if category in pivot_data.columns
                        else 0.0
                    )
                data.append(month_data)

            return {
                "success": True,
                "start_year": start_year,
                "start_month": start_month,
                "end_year": end_year,
                "end_month": end_month,
                "categories": categories,
                "months": months,
                "data": data,
            }

        except HTTPException:
            raise
        except Exception as e:
            logger.exception(f"Error getting category breakdown: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    # Store cache and streamer as app state for external access
    app.state.chart_cache = chart_cache
    app.state.image_streamer = image_streamer

    return app
