"""FastAPI HTTP server for serving chart images.

This module provides HTTP endpoints for streaming chart images
generated by the household budget analysis tools.
"""

from __future__ import annotations

import logging
from typing import Any, Optional

try:
    from fastapi import FastAPI, HTTPException, Query
    from fastapi.middleware.cors import CORSMiddleware
    from fastapi.responses import StreamingResponse

    HAS_FASTAPI = True
except ImportError:
    HAS_FASTAPI = False

from household_mcp.streaming import ImageStreamer
from household_mcp.streaming.global_cache import ensure_global_cache, get_global_cache

logger = logging.getLogger(__name__)


def create_http_app(
    enable_cors: bool = True,
    allowed_origins: Optional[list[str]] = None,
    cache_size: int = 50,
    cache_ttl: int = 3600,
) -> "FastAPI":
    """Create FastAPI application for chart streaming.

    Args:
        enable_cors: Whether to enable CORS middleware
        allowed_origins: List of allowed origins for CORS.
                        Defaults to ["*"] if None.
        cache_size: Maximum number of cached charts (default: 50)
        cache_ttl: Cache TTL in seconds (default: 3600 = 1 hour)

    Returns:
        Configured FastAPI application

    Raises:
        ImportError: If FastAPI is not installed
    """
    if not HAS_FASTAPI:
        raise ImportError(
            "FastAPI is required for HTTP server. "
            "Install with: pip install household-mcp-server[streaming]"
        )

    app = FastAPI(
        title="Household Budget Chart Server",
        description="HTTP streaming server for household budget charts",
        version="0.1.0",
    )

    # Initialize cache and streamer (use global shared cache when possible)
    chart_cache = get_global_cache() or ensure_global_cache(
        max_size=cache_size, ttl=cache_ttl
    )
    if chart_cache is None:
        # Fallback: raise with clear guidance on missing extras
        raise ImportError(
            "cachetools is required for chart caching. "
            "Install with: pip install household-mcp-server[streaming]"
        )
    image_streamer = ImageStreamer(chunk_size=8192)

    # CORS configuration
    if enable_cors:
        origins = allowed_origins or ["*"]
        app.add_middleware(
            CORSMiddleware,
            allow_origins=origins,
            allow_credentials=True,
            allow_methods=["GET"],
            allow_headers=["*"],
        )

    @app.get("/api/charts/{chart_id}")
    async def stream_chart(chart_id: str) -> "StreamingResponse":  # type: ignore[no-untyped-def]
        """Stream a generated chart image.

        Args:
            chart_id: Unique identifier for the chart (cache key)

        Returns:
            StreamingResponse with image data

        Raises:
            HTTPException: If chart not found in cache (404)
        """
        logger.info(f"Request for chart: {chart_id}")

        # Retrieve from cache
        image_data = chart_cache.get(chart_id)
        if image_data is None:
            logger.warning(f"Chart not found: {chart_id}")
            raise HTTPException(status_code=404, detail=f"Chart '{chart_id}' not found")

        # Stream the image
        logger.info(f"Streaming chart: {chart_id} ({len(image_data)} bytes)")
        return image_streamer.create_response(
            image_data,
            media_type="image/png",
            filename=f"chart_{chart_id}.png",
        )

    @app.get("/api/charts/{chart_id}/info")
    async def get_chart_info(chart_id: str) -> dict[str, object]:  # type: ignore[no-untyped-def]
        """Get information about a cached chart.

        Args:
            chart_id: Unique identifier for the chart

        Returns:
            Dictionary with chart metadata

        Raises:
            HTTPException: If chart not found in cache (404)
        """
        image_data = chart_cache.get(chart_id)
        if image_data is None:
            raise HTTPException(status_code=404, detail=f"Chart '{chart_id}' not found")

        return {
            "chart_id": chart_id,
            "size_bytes": len(image_data),
            "media_type": "image/png",
        }

    @app.get("/api/cache/stats")
    async def get_cache_stats() -> dict[str, object]:  # type: ignore[no-untyped-def]
        """Get cache statistics.

        Returns:
            Dictionary with cache statistics
        """
        return chart_cache.stats()

    @app.delete("/api/cache")
    async def clear_cache() -> dict[str, object]:  # type: ignore[no-untyped-def]
        """Clear all cached charts.

        Returns:
            Confirmation message
        """
        chart_cache.clear()
        logger.info("Cache cleared")
        return {"status": "success", "message": "Cache cleared"}

    @app.get("/health")
    async def health_check() -> dict[str, object]:  # type: ignore[no-untyped-def]
        """Health check endpoint.

        Returns:
            Health status
        """
        return {"status": "healthy", "cache_size": chart_cache.size()}

    # MCP Tool API endpoints
    @app.get("/api/monthly")
    async def get_monthly_data(  # type: ignore[no-untyped-def]
        year: int = Query(..., description="Year"),  # type: ignore[assignment]
        month: int = Query(..., description="Month (1-12)"),  # type: ignore[assignment]
        output_format: str = Query("json", description="Output format: json or image"),  # type: ignore[assignment]
        graph_type: str = Query("pie", description="Graph type: pie, bar, line, area"),  # type: ignore[assignment]
        image_size: str = Query("800x600", description="Image size (WxH)"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """Get monthly household data.

        Args:
            year: Year
            month: Month (1-12)
            output_format: Output format (json or image)
            graph_type: Graph type (pie, bar, line, area)
            image_size: Image size (WxH)

        Returns:
            Monthly data or image information
        """
        try:
            import os

            from household_mcp.dataloader import HouseholdDataLoader
            from household_mcp.tools.enhanced_tools import enhanced_monthly_summary

            data_dir = os.getenv("HOUSEHOLD_DATA_DIR", "data")

            if output_format == "image":
                # Generate image
                result = enhanced_monthly_summary(
                    year=year,
                    month=month,
                    output_format="image",
                    graph_type=graph_type,
                    image_size=image_size,
                )
                return result  # type: ignore[return-value]
            else:
                # Return JSON data
                loader = HouseholdDataLoader(src_dir=data_dir)
                df = loader.load_month(year, month)
                records = df.to_dict(orient="records")
                return {
                    "success": True,
                    "year": year,
                    "month": month,
                    "data": records,
                    "count": len(records),
                }
        except Exception as e:
            logger.exception(f"Error getting monthly data: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/available-months")
    async def get_available_months() -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """Get list of available months.

        Returns:
            List of available year-month combinations
        """
        try:
            import os

            from household_mcp.dataloader import HouseholdDataLoader

            data_dir = os.getenv("HOUSEHOLD_DATA_DIR", "data")
            loader = HouseholdDataLoader(src_dir=data_dir)
            months = [
                {"year": year, "month": month}
                for year, month in loader.iter_available_months()
            ]
            return {"success": True, "months": months}
        except Exception as e:
            logger.exception(f"Error getting available months: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/category-hierarchy")
    async def get_category_hierarchy(  # type: ignore[no-untyped-def]
        year: int = Query(2025, description="Year"),  # type: ignore[assignment]
        month: int = Query(1, description="Month"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """Get category hierarchy.

        Args:
            year: Year
            month: Month

        Returns:
            Category hierarchy
        """
        try:
            import os

            from household_mcp.dataloader import HouseholdDataLoader

            data_dir = os.getenv("HOUSEHOLD_DATA_DIR", "data")
            loader = HouseholdDataLoader(src_dir=data_dir)
            hierarchy = loader.category_hierarchy(year=year, month=month)
            return {"success": True, "hierarchy": dict(hierarchy)}
        except Exception as e:
            logger.exception(f"Error getting category hierarchy: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    # Duplicate detection endpoints
    @app.post("/api/duplicates/detect")
    async def detect_duplicates(  # type: ignore[no-untyped-def]
        date_tolerance_days: int = Query(0, description="Date tolerance in days"),  # type: ignore[assignment]
        amount_tolerance_abs: float = Query(0.0, description="Absolute amount tolerance"),  # type: ignore[assignment]
        amount_tolerance_pct: float = Query(0.0, description="Percentage amount tolerance"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """Detect duplicate transactions.

        Args:
            date_tolerance_days: Date tolerance in days (default: 0)
            amount_tolerance_abs: Absolute amount tolerance (default: 0.0)
            amount_tolerance_pct: Percentage amount tolerance (default: 0.0)

        Returns:
            Detection results with count
        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.detect_duplicates(
                date_tolerance_days=date_tolerance_days,
                amount_tolerance_abs=amount_tolerance_abs,
                amount_tolerance_pct=amount_tolerance_pct,
            )
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error detecting duplicates: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/duplicates/candidates")
    async def get_duplicate_candidates(  # type: ignore[no-untyped-def]
        limit: int = Query(10, description="Maximum number of candidates to return"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """Get list of duplicate candidates.

        Args:
            limit: Maximum number of candidates to return (default: 10)

        Returns:
            List of duplicate candidate pairs
        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.get_duplicate_candidates(limit=limit)
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error getting duplicate candidates: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/duplicates/{check_id}")
    async def get_duplicate_detail(check_id: int) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """Get details of a duplicate candidate.

        Args:
            check_id: Duplicate check ID

        Returns:
            Detailed information about the duplicate candidate
        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.get_duplicate_candidate_detail(check_id=check_id)
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error getting duplicate detail: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.post("/api/duplicates/{check_id}/confirm")
    async def confirm_duplicate(  # type: ignore[no-untyped-def]
        check_id: int,
        decision: str = Query(..., description="Decision: duplicate, not_duplicate, or skip"),  # type: ignore[assignment]
    ) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """Confirm duplicate decision.

        Args:
            check_id: Duplicate check ID
            decision: Decision (duplicate, not_duplicate, or skip)

        Returns:
            Confirmation result
        """
        if decision not in ["duplicate", "not_duplicate", "skip"]:
            raise HTTPException(
                status_code=400,
                detail="Invalid decision. Must be 'duplicate', 'not_duplicate', or 'skip'",
            )

        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.confirm_duplicate(
                check_id=check_id, decision=decision  # type: ignore[arg-type]
            )
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error confirming duplicate: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.post("/api/duplicates/restore/{transaction_id}")
    async def restore_duplicate(transaction_id: int) -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """Restore a transaction marked as duplicate.

        Args:
            transaction_id: Transaction ID to restore

        Returns:
            Restoration result
        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.restore_duplicate(transaction_id=transaction_id)
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error restoring duplicate: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    @app.get("/api/duplicates/stats")
    async def get_duplicate_stats() -> dict[str, Any]:  # type: ignore[no-untyped-def]
        """Get duplicate detection statistics.

        Returns:
            Statistics about detected duplicates
        """
        try:
            from household_mcp.tools import duplicate_tools

            result = duplicate_tools.get_duplicate_stats()
            return result  # type: ignore[return-value]
        except Exception as e:
            logger.exception(f"Error getting duplicate stats: {e}")
            raise HTTPException(status_code=500, detail=str(e))

    # Store cache and streamer as app state for external access
    app.state.chart_cache = chart_cache
    app.state.image_streamer = image_streamer

    return app
