# 家計簿MCPサーバ設計仕様書

## 1. 概要

### 1.1 目的

家計簿データ（CSVファイル）を読み取り、MCPサーバとして検索・集計・分析機能を提供するチュートリアルプロジェクト

### 1.2 対象範囲

- CSVファイルからの家計簿データ読み込み
- SQLiteデータベースへのデータ蓄積
- 取引データの検索・絞り込み
- 収支の集計・分析
- 統計情報の提供

## 2. データ仕様

### 2.1 CSVファイル構造

```csv
計算対象,日付,内容,金額(円),保有金融機関,費目,内訳,メモ,振替,ID
```

### 2.2 データ項目定義

| 項目名 | 型 | 説明 | 例 |
|--------|----|----|-----|
| 計算対象 | string | 計算に含めるか（"0"/"1"） | "1" |
| 日付 | string | 取引日 | "2024/01/31" |
| 内容 | string | 取引内容・説明 | "スーパーマーケット" |
| 金額(円) | number | 取引金額（負：支出、正：収入） | -2500 |
| 保有金融機関 | string | 取引元の金融機関 | "現金" |
| 費目 | string | 支出・収入の大分類 | "食費" |
| 内訳 | string | 支出・収入の小分類 | "スーパー・ドラッグ" |
| メモ | string | 補足情報 | "まとめ買い" |
| 振替 | string | 振替取引フラグ（"0"/"1"） | "0" |
| ID | string | 取引の一意識別子 | "abc123..." |

### 2.3 SQLiteテーブル設計

#### transactions テーブル

```sql
CREATE TABLE transactions (
    id TEXT PRIMARY KEY,
    include_in_calc INTEGER NOT NULL,
    date TEXT NOT NULL,
    content TEXT NOT NULL,
    amount INTEGER NOT NULL,
    institution TEXT NOT NULL,
    category TEXT NOT NULL,
    subcategory TEXT,
    memo TEXT,
    is_transfer INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_transactions_date ON transactions(date);
CREATE INDEX idx_transactions_category ON transactions(category);
CREATE INDEX idx_transactions_amount ON transactions(amount);
CREATE INDEX idx_transactions_is_transfer ON transactions(is_transfer);
```

### 2.4 データ処理ルール

- **エンコーディング**: Shift-JIS
- **日付形式**: YYYY/MM/DD → YYYY-MM-DD（SQLite用）
- **金額**: 負の値は支出、正の値は収入
- **振替取引**: 振替フラグが"1"の場合、収支計算時に除外可能

## 3. 機能仕様

### 3.1 提供するMCPツール

#### 3.1.1 search_transactions

**目的**: 条件に基づく取引検索

**パラメータ**:

```json
{
  "date_from": "2024-01-01",
  "date_to": "2024-01-31",
  "amount_min": -100000,
  "amount_max": 100000,
  "content": "スーパー",
  "category": "食費",
  "subcategory": "スーパー・ドラッグ",
  "include_transfers": false,
  "limit": 50
}
```

**戻り値**:

```json
{
  "transactions": [
    {
      "date": "2024/01/31",
      "content": "スーパーマーケット",
      "amount": -2500,
      "institution": "現金",
      "category": "食費",
      "subcategory": "スーパー・ドラッグ",
      "memo": "",
      "is_transfer": false,
      "id": "abc123..."
    }
  ],
  "total_count": 1,
  "filtered_count": 1
}
```

#### 3.1.2 get_monthly_summary

**目的**: 月次収支サマリー

**パラメータ**:

```json
{
  "year": 2024,
  "month": 1,
  "include_transfers": false
}
```

**戻り値**:

```json
{
  "year": 2024,
  "month": 1,
  "income": 500000,
  "expense": -150000,
  "balance": 350000,
  "transaction_count": 45,
  "categories": {
    "食費": -50000,
    "住居": -80000,
    "給与": 500000
  }
}
```

#### 3.1.3 get_category_summary

**目的**: 費目別集計

**パラメータ**:

```json
{
  "date_from": "2024-01-01",
  "date_to": "2024-01-31",
  "include_transfers": false,
  "group_by": "category"
}
```

**戻り値**:

```json
{
  "period": {
    "from": "2024-01-01",
    "to": "2024-01-31"
  },
  "categories": [
    {
      "name": "食費",
      "amount": -50000,
      "count": 15,
      "percentage": 33.3,
      "subcategories": {
        "スーパー・ドラッグ": -30000,
        "外食": -20000
      }
    }
  ],
  "total_expense": -150000,
  "total_income": 500000
}
```

#### 3.1.4 get_balance_summary

**目的**: 全体収支バランス

**パラメータ**:

```json
{
  "date_from": "2024-01-01",
  "date_to": "2024-01-31",
  "include_transfers": false
}
```

**戻り値**:

```json
{
  "period": {
    "from": "2024-01-01",
    "to": "2024-01-31"
  },
  "summary": {
    "total_income": 500000,
    "total_expense": -150000,
    "net_balance": 350000,
    "transaction_count": 45
  },
  "daily_balance": [
    {
      "date": "2024-01-01",
      "income": 0,
      "expense": -5000,
      "balance": -5000
    }
  ]
}
```

#### 3.1.5 get_transaction_stats

**目的**: 統計情報

**パラメータ**:

```json
{
  "date_from": "2024-01-01",
  "date_to": "2024-01-31",
  "include_transfers": false
}
```

**戻り値**:

```json
{
  "period": {
    "from": "2024-01-01",
    "to": "2024-01-31"
  },
  "statistics": {
    "avg_expense": -3333,
    "avg_income": 125000,
    "max_expense": {
      "amount": -50000,
      "content": "家賃",
      "date": "2024-01-01"
    },
    "max_income": {
      "amount": 500000,
      "content": "給与",
      "date": "2024-01-25"
    },
    "most_frequent_category": "食費",
    "expense_categories_count": 8,
    "income_categories_count": 3
  }
}
```

## 4. 技術仕様

### 4.1 開発環境

- **言語**: Python 3.9以上
- **MCPライブラリ**: `mcp`
- **データベース**: SQLite3
- **CSVパーサー**: `pandas`
- **文字エンコーディング**: `chardet`（自動判定）

### 4.2 プロジェクト構成

```plaintext
my_household_mcpserver/
├── src/
│   ├── __init__.py
│   ├── main.py               # MCPサーバエントリポイント
│   ├── csv_reader.py         # CSVファイル読み込み
│   ├── database.py           # SQLiteデータベース操作
│   ├── transaction_service.py # 取引データ処理サービス
│   └── models.py             # データモデル定義
├── data/
│   ├── household_data.csv    # 家計簿データ
│   └── transactions.db       # SQLiteデータベース
├── tests/
│   ├── __init__.py
│   ├── test_csv_reader.py    # CSVリーダーテスト
│   ├── test_database.py      # データベーステスト
│   └── test_transaction_service.py # サービステスト
├── changelog.d/              # towncrier変更フラグメント
│   ├── template.rst          # Changelogテンプレート
│   └── README.md            # 変更フラグメントの説明
├── requirements.txt
├── pyproject.toml
├── CHANGELOG.md             # 自動生成されるChangelog
├── README.md
└── DESIGN.md
```

### 4.3 主要な依存関係

```txt
mcp>=1.0.0
pandas>=2.0.0
sqlite3
chardet>=5.0.0
pytest>=7.0.0
pytest-asyncio>=0.21.0
towncrier>=23.0.0
```

### 4.4 データ処理フロー

1. CSVファイルをShift-JISエンコーディングで読み込み
2. pandasでデータフレームに変換
3. データクレンジング・正規化
4. SQLiteデータベースに挿入/更新
5. MCPツールからの要求に応じてSQL検索・集計
6. 結果をJSON形式で返却

### 4.5 エラーハンドリング

- CSVファイルが存在しない場合のエラー
- 不正な日付形式のエラー
- 不正な金額データのエラー
- データベース接続エラー
- メモリ不足時のエラー

## 5. 非機能要件

### 5.1 パフォーマンス

- 10,000件の取引データを5秒以内で処理
- メモリ使用量を500MB以下に制限
- SQLiteインデックスによる高速検索

### 5.2 可用性

- CSVファイルの破損に対する耐性
- 部分的なデータでも処理継続
- データベースの自動バックアップ

### 5.3 拡張性

- 複数のCSVファイルサポート（将来拡張）
- 新しい集計パターンの追加容易性
- データベーススキーマのマイグレーション対応

### 5.4 学習効率化（AIエージェント活用）

- **理解度確認**: 実装前に作業者の理解度を確認し、十分な理解を確認してから実装を開始
- **理解状況記録**: 作業者の理解状況を記録し、既習内容の編集時には理解度確認を省略可能
- **忘却対応**: 時間経過による忘却を前提とした定期的な再確認の実施
- **段階的学習**: 複雑な概念を段階的に分解して理解を促進
- **実装パターン学習**: 類似の実装パターンの経験を蓄積し、効率的な実装を支援

### 5.5 バージョン管理自動化

- **自動バージョニング**: セマンティックバージョニング（SemVer）に基づく自動バージョン管理
- **変更履歴管理**: towncrierによる構造化されたChangelogの自動生成
- **リリース自動化**: タグ付け、ビルド、デプロイの自動化
- **変更追跡**: 機能追加、バグ修正、破壊的変更の分類と記録
- **リリースノート**: 自動生成されたリリースノートの品質確保

## 6. 実装手順

### Phase 1: 基本実装

1. プロジェクト初期化（pyproject.toml, requirements.txt）
2. **バージョン管理**: towncrierの設定と初期化
3. **TDD**: CSVリーダーの失敗テストを書く（Red）
4. CSVリーダーの最小実装（Green）
5. データモデルの改善（Refactor）
6. **変更記録**: 機能追加の変更フラグメント作成
7. SQLiteデータベース設計・作成
8. **TDD**: データベース操作の失敗テストを書く（Red）
9. 基本的なデータベース操作実装（Green）
10. MCPサーバの基本骨格
11. **テスト**: 単体テストの実行と検証
12. **ドキュメント**: README.mdの基本情報
13. **バージョン管理**: 初回リリース（v0.1.0）とChangelog生成
14. **学習確認**: TDDサイクルの理解度確認と記録

### Phase 2: 機能実装

1. **TDD**: search_transactions の失敗テストを書く（Red）
2. search_transactions の最小実装（Green）
3. **変更記録**: 機能追加の変更フラグメント作成
4. **TDD**: get_monthly_summary の失敗テストを書く（Red）
5. get_monthly_summary の最小実装（Green）
6. **変更記録**: 機能追加の変更フラグメント作成
7. **TDD**: get_category_summary の失敗テストを書く（Red）
8. get_category_summary の最小実装（Green）
9. **変更記録**: 機能追加の変更フラグメント作成
10. 各機能のリファクタリング（Refactor）
11. **テスト**: 統合テストの実装
12. **ドキュメント**: API仕様書の作成
13. **バージョン管理**: マイナーリリース（v0.2.0）とChangelog生成
14. **学習確認**: テストピラミッドの理解度確認と記録

### Phase 3: 拡張機能

1. **TDD**: get_balance_summary の失敗テストを書く（Red）
2. get_balance_summary の最小実装（Green）
3. **変更記録**: 機能追加の変更フラグメント作成
4. **TDD**: get_transaction_stats の失敗テストを書く（Red）
5. get_transaction_stats の最小実装（Green）
6. **変更記録**: 機能追加の変更フラグメント作成
7. エラーハンドリング強化（TDD）
8. **変更記録**: 改善の変更フラグメント作成
9. 全体的なリファクタリング（Refactor）
10. **テスト**: E2Eテストの実装
11. **ドキュメント**: 使用例の追加
12. **バージョン管理**: マイナーリリース（v0.3.0）とChangelog生成
13. **学習確認**: 複雑な機能の理解度確認と忘却対応

### Phase 4: 最適化・完成

1. **TDD**: パフォーマンステストを書く（Red）
2. パフォーマンス最適化の実装（Green）
3. **変更記録**: パフォーマンス改善の変更フラグメント作成
4. セキュリティ対策の追加（TDD）
5. **変更記録**: セキュリティ改善の変更フラグメント作成
6. 本番環境対応
7. 全体的なコード品質向上（Refactor）
8. **テスト**: 負荷テスト・エラーケーステスト
9. **ドキュメント**: 運用ガイドの作成
10. **バージョン管理**: メジャーリリース（v1.0.0）とChangelog生成
11. **学習確認**: TDD実践度の最終確認

## 7. テスト戦略（TDD: Test-Driven Development）

### 7.1 TDDサイクル（Red-Green-Refactor）

1. **Red**: 失敗するテストを書く
2. **Green**: テストが通る最小限のコードを書く
3. **Refactor**: 動作を変えずにコードを改善する

### 7.2 テストピラミッド

```plaintext
        E2E Tests
       (少数・重要)
      /            \
   Integration Tests
   (中程度・重要な経路)
  /                    \
Unit Tests
(多数・高速・詳細)
```

### 7.3 単体テスト（Unit Tests）

**目的**: 個々の関数・メソッドの動作を検証

**対象**:

- CSVリーダーの各機能
- データベース操作の各メソッド
- 各MCPツールの機能
- データモデルの変換処理

**TDDアプローチ**:

```python
# 例: CSVリーダーのテスト
def test_csv_reader_should_parse_household_data():
    # Red: 失敗するテストを先に書く
    csv_content = "計算対象,日付,内容,金額(円)...\n1,2024/01/01,テスト,-1000..."
    reader = CSVReader()
    
    result = reader.parse(csv_content)
    
    assert len(result) == 1
    assert result[0].amount == -1000
    assert result[0].category == "テスト"
```

### 7.4 統合テスト（Integration Tests）

**目的**: 複数のコンポーネント間の連携を検証

**対象**:

- CSV読み込みからデータベース保存までの一連の処理
- MCPサーバとクライアントの通信
- データベースとサービス層の連携

**TDDアプローチ**:

- 外部依存（ファイル、DB）を含むシナリオテスト
- モックを使用した境界の検証
- エラーハンドリングの統合テスト

### 7.5 E2Eテスト（End-to-End Tests）

**目的**: ユーザーシナリオ全体の動作を検証

**対象**:

- 実際のCSVファイルを使用したフルシナリオ
- MCPクライアントからの実際の要求・応答
- パフォーマンス要件の検証

### 7.6 テスト駆動開発の実践指針

#### 7.6.1 テストファースト原則

- コードを書く前に必ずテストを書く
- テストが失敗することを確認してから実装開始
- テストが通る最小限のコードのみを書く

#### 7.6.2 テストの品質

- **FIRST原則**:
  - **F**ast: 高速に実行される
  - **I**ndependent: 独立して実行可能
  - **R**epeatable: 繰り返し実行可能
  - **S**elf-validating: 自己検証可能
  - **T**imely: 適切なタイミングで書かれる

#### 7.6.3 テストの構造（AAA パターン）

```python
def test_example():
    # Arrange: テストの前提条件を設定
    csv_data = create_test_csv_data()
    reader = CSVReader()
    
    # Act: テスト対象の処理を実行
    result = reader.parse(csv_data)
    
    # Assert: 結果を検証
    assert len(result) == expected_count
    assert result[0].amount == expected_amount
```

### 7.7 TDDフェーズ別テスト戦略

#### Phase 1: 基本実装（テスト戦略）

- **Red**: CSVパーサーの失敗テストを書く
- **Green**: 最小限のパーサー実装
- **Refactor**: データモデルの改善
- **学習確認**: TDDサイクルの理解度確認

#### Phase 2: 機能実装（テスト戦略）

- **Red**: 各MCPツールの失敗テストを書く
- **Green**: 機能の最小実装
- **Refactor**: サービス層の整理
- **学習確認**: テストピラミッドの理解度確認

#### Phase 3: 拡張機能（テスト戦略）

- **Red**: 複雑な集計機能の失敗テストを書く
- **Green**: 段階的な機能追加
- **Refactor**: アーキテクチャの改善
- **学習確認**: 統合テストの理解度確認

#### Phase 4: 最適化・完成（テスト戦略）

- **Red**: パフォーマンステストを書く
- **Green**: 最適化の実装
- **Refactor**: 全体的なコード品質向上
- **学習確認**: E2Eテストの理解度確認

### 7.8 モックとスタブの活用

- **モック**: 外部依存の振る舞いを検証
- **スタブ**: 外部依存の戻り値を制御
- **フェイク**: 軽量な実装で代替

### 7.9 継続的テスト

- コミット前のテスト実行
- CI/CDパイプラインでの自動テスト
- カバレッジ測定とレポート

### 7.10 学習効率化テスト

- 理解度確認プロセスの有効性検証（TDD実践度）
- 学習記録システムの動作確認（テスト品質記録）
- 忘却対応メカニズムの検証（TDDサイクル理解度）

## 8. 学習支援システム

学習支援システムの詳細については、[学習支援システム設計仕様書](./docs/learning_support/学習支援システム設計仕様書.md)を参照してください。

### 8.1 概要

このプロジェクトには、プログラミング学習とTDD実践の効率化を目的とした学習支援システムが統合されています。

### 8.2 主な機能

- **理解度自動推定**: AIエージェントがユーザーとの対話から理解度を推定
- **学習パス生成**: 個別化された学習戦略の自動生成
- **TDD実践追跡**: Red-Green-Refactorサイクルの実践状況記録
- **忘却対応メカニズム**: 間隔反復学習による知識定着支援
- **復習スケジュール管理**: 最適な復習タイミングの自動提案

### 8.3 実装場所

学習支援システムの実装は、`.learning_support/` ディレクトリに配置されています。

### 8.4 ドキュメント

- [学習支援システム設計仕様書](./docs/learning_support/学習支援システム設計仕様書.md)
- [AIエージェント行動規範](./docs/learning_support/AIエージェント行動規範.md)
- [学習支援システム実装詳細](./docs/learning_support/README.md)

## 9. バージョン管理・リリース管理

### 9.1 セマンティックバージョニング（SemVer）

- **メジャーバージョン**: 破壊的変更（例: v1.0.0 → v2.0.0）
- **マイナーバージョン**: 機能追加（例: v1.0.0 → v1.1.0）
- **パッチバージョン**: バグ修正（例: v1.0.0 → v1.0.1）

### 9.2 towncrierによるChangelog管理

#### 9.2.1 pyproject.tomlの設定

```toml
[tool.towncrier]
package = "my_household_mcpserver"
package_dir = "src"
filename = "CHANGELOG.md"
directory = "changelog.d"
template = "changelog.d/template.rst"
title_format = "# Changelog\n\n## {version} ({project_date})\n\n"
issue_format = "#{issue}"

[[tool.towncrier.type]]
directory = "feature"
name = "Features"
showcontent = true

[[tool.towncrier.type]]
directory = "bugfix"
name = "Bug Fixes"
showcontent = true

[[tool.towncrier.type]]
directory = "doc"
name = "Documentation"
showcontent = true

[[tool.towncrier.type]]
directory = "removal"
name = "Removals and Deprecations"
showcontent = true

[[tool.towncrier.type]]
directory = "misc"
name = "Miscellaneous"
showcontent = true
```

#### 9.2.2 変更フラグメントの作成

```bash
# 機能追加の場合
echo "CSVリーダーの基本機能を追加" > changelog.d/001.feature.md

# バグ修正の場合
echo "SQLiteデータベース接続エラーを修正" > changelog.d/002.bugfix.md

# ドキュメント更新の場合
echo "README.mdにインストール手順を追加" > changelog.d/003.doc.md
```

#### 9.2.3 Changelogの生成

```bash
# 変更フラグメントからChangelogを生成
towncrier --draft  # プレビュー
towncrier --version 1.0.0  # 本番生成
```

### 9.3 リリースフロー

#### 9.3.1 開発フロー

1. **機能開発**: 新機能・修正の実装
2. **変更記録**: 適切な変更フラグメントの作成
3. **テスト**: 単体・統合・E2Eテストの実行
4. **レビュー**: コード品質とテストカバレッジの確認

#### 9.3.2 リリースフロー

1. **バージョン決定**: SemVerに基づくバージョン番号の決定
2. **Changelog生成**: towncrierによる自動生成
3. **タグ付け**: Gitタグの作成
4. **ビルド**: パッケージのビルド
5. **配布**: PyPIまたは内部リポジトリへの配布

### 9.4 変更分類とガイドライン

#### 9.4.1 機能追加（feature）

- 新しいMCPツールの追加
- 既存機能の拡張
- パフォーマンス向上

#### 9.4.2 バグ修正（bugfix）

- 既存機能の不具合修正
- エラーハンドリングの改善
- セキュリティ脆弱性の修正

#### 9.4.3 ドキュメント（doc）

- README.mdの更新
- API仕様書の追加・修正
- コードコメントの改善

#### 9.4.4 削除・非推奨（removal）

- 古いAPIの削除
- 非推奨機能の除去
- 依存関係の削除

#### 9.4.5 その他（misc）

- 内部リファクタリング
- テストの追加・改善
- 設定ファイルの更新

### 9.5 自動化とCI/CD統合

#### 9.5.1 GitHub Actions例

```yaml
name: Release
on:
  push:
    tags: ['v*']

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    - name: Install dependencies
      run: |
        pip install towncrier build
    - name: Generate changelog
      run: towncrier --version ${{ github.ref_name }}
    - name: Build package
      run: python -m build
    - name: Create release
      uses: actions/create-release@v1
      with:
        tag_name: ${{ github.ref_name }}
        release_name: Release ${{ github.ref_name }}
        body_path: CHANGELOG.md
```

#### 9.5.2 品質ゲート

- テストカバレッジ > 90%
- 全てのテストがPASS
- 静的解析エラーなし
- 変更フラグメントの存在確認

### 9.6 学習効率化との連携

#### 9.6.1 バージョン管理理解度の記録

```json
{
  "concept": "towncrierによるChangelog管理",
  "understanding_level": "intermediate",
  "last_confirmed": "2025-07-06",
  "implementation_count": 2,
  "tdd_proficiency": "advanced",
  "version_management_proficiency": "beginner",
  "notes": "基本的な変更フラグメント作成は理解済み"
}
```

#### 9.6.2 リリース作業の理解度確認

- セマンティックバージョニングの理解
- 変更フラグメントの適切な分類
- towncrierコマンドの使い方
- リリースフローの把握
